# 스트림 병렬화는 주의해서 적용하라

자바 7부터 고성능 병렬 분해 프레임워크인 포크-조인(fork-join) 패키지가 추가되었다.

그리고 자바 8부터는 parallel 메서드만 한 번 호출하면 파이프라인을 병렬 실행할 수 있는 스트림을 지원했다. 

자바로 동시성 프로그램을 작성하는 일은 점점 쉬워지고 있지만 올바르게 쓰는건 여전히 어려운 작업이다.

## 스트림 병렬화가 잘못 사용된 경우

동시성 프로그래밍을 할 때는 안전성(올바른 결과 보장)과 응답 가능 상태(적절한 시간내 응답해야함)를 유지하기 위해 애써야 하는데 
자바의 병렬 스트림 파이프라인 프로그래밍에서도 마찬가지다.

아래는 처음 20개의 메르센 소수를 생성하는 프로그램이다. 저자의 컴퓨터에서는 12.5초만에 완료가 되었다.    

```java
public static void main(String[] args) {
    primes().map(p -> TWO.pow(p.intValueExact()).subtract(ONE))
            .filter(mersenne -> mersenne.isProbablePrime(50))
            .limit(20)
            .forEach(System.out::println);
}

static Stream<BigInteger> primes() {
    // 무한정 순환하는 스트림을 반환한다.
    return Stream.iterate(TWO, BigInteger::nextProbablePrime);
}
```

위 코드의 성능을 개선하기 위해 parallel를 적용했다고 가정해보자. 안타깝게도 이 프로그램은 아무것도 출력하지 못한다.(CPU를 90%나 잡아먹었다!!)

**parallel을 적용하자 응답불가 상태가 되어버렸다.**

## 느려진 원인은 무엇일까?

어이없게도 스트림 라이브러리가 이 파이프라인을 병렬화 하는 방법을 찾아내지 못했기 때문이다.)


데이터 소스가 Stream.iterate거나 중간 연산으로 limit를 쓰면 파이프라인 병렬화로는 성능 개선을 기대할 수 없다.그런데 앞서본 코드는 이 2개를 모두 가지고 있다. 즉, parellel을 사용하기에 최악인 상태이다.

(아마도 Stream.iterate는 최종 개수가 확정되어있지 않는 무한 스트림을 반환하기 때문에 병렬화가 불가능한 것 같다.)


## 병렬화를 적용하기 적절한 자료구조

스트림의 소스가 ArrayList, HashMap, HashSet, ConcurrentHashMap의 인스턴스거나 배열, int 범위, long 범위일 때 병렬화의 효과가 가장 좋다.

이런 자료구조들은 모두 데이터를 원하는 크기로 정확하고 손쉽게 나눌 수 있다.

이 자료구조들은 `참조 지역성`이 뛰어나다. 쉽게 말하면 메모리의 특정 위치에 연속해서 저장되어 있다는 뜻이다.
(그중에서 최고는 배열이다.)

참조 지역성이 나쁘면 스레드는 데이터가 주 메모리에서 캐시 메모리로 전송되어 오기를 기다리며 대부분 시간을 멍하게 보내게 된다.

## 스트림 파이프라인의 종단 연산자

병렬 수행에 영향을 주는 요소로 `스트림 파이프라인의 종단 연산`이 있다.

종단 연산자에서 수행하는 작업량이 파이프라인 전체 작업에서 상당한 비중을 차지하고 있으므로 여기서 성능이 나오지 않는다면 전체적인 파이프라인 성능이 저하된다.

종단 연산중 병렬화에 가장 적합한 것은 축소(reduction)이다. (예를 들어, `count`, `max`, `min`, `sum` 등)

축소는 파이프라인에서 만들어진 모든 원소를 하나로 합치는 작업이다.

또한 anyMatch, allMatch, noneMatch, findFirst, findAny 처럼 조건에 맞으면 바로 반환하는 종단 연산자도 병렬화에 적합하다.

반면에 가변 축소 연산(mutable reduction)인 collect는 병렬화하기에 적합하지 않다. (결과의 개수가 보장되지 않기 때문이다.)

## spliterator

병렬화의 이점을 제대로 누리고 싶다면 spliterator를 반드시 재정의하고 결과 스트림의 병렬화 성능을 강도높게 측정해야한다.

운영과 유사한 환경에서 테스트 하라!!

또한 parellel은 공통 fork-join 쓰레드 풀을 사용하므로 다른 작업에 영향을 줄 수 있으므로 주의해야한다.

명세서가 제시하는 요구사항을 지키지 못한다면 참혹한 실패로 이어지기 십상이다.

## 성능 향상 측정 방법

스트림 안의 원소 수와 원소당 수행되는 코드 줄 수를 곱해보자. 이 값이 최소 수십만은 되어야 성능 향상을 맛볼 수 있다.

## 성능 향상이 가능한 케이스

조건만 잘 갖춰지면 parallel 메서드 호출 하나로 거의 프로세서 코어 수에 비례하는 성능 향상을 만끽할 수 있다.

아래는 소수 계산 스트림 파이프라인이다.(병렬화 적용전)

```java
static long pi(long n) {
    return LongStream.rangeClosed(2, n)
            .mapToObj(BigInteger::valueOf)
            .filter(i -> i.isProbablePrime(50))
            .count();
}
```

병렬화 적용 후.
```java
static long pi(long n) {
    return LongStream.rangeClosed(2, n)
            .parallel() // 추가
            .mapToObj(BigInteger::valueOf)
            .filter(i -> i.isProbablePrime(50))
            .count();
}
```

저자의 컴퓨터에서 31초가 걸리던 작업이 9.2초로 단축되었다. (쿼드코어 사용중)

n이 크다면 레머의 공식이라는 알고리즘 쓰는게 더 효율적이긴하다.

## 병렬화를 쓰려면...

병렬화를 적용하고 나서 올바른 결과를 출력하는지 테스트를 해야하며, 운영 환경과 유사한 조건에서 성능을 측정해야한다.




