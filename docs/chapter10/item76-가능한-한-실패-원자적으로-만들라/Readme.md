# 가능한 한 실패 원자적으로 만들라

## 실패 원자적(failure-atomic)이란?

실패 원자적이란, 호출된 메서드가 실패하더라도 해당 객체는 메서드 호출 전 상태를 유지해야한다는 것을 의미한다.

```java
public class Car {
    
    private Power power;
    
    ...
    
    public void turnOff() {
        // power 를 Power.OFF 값으로 변경한다.
        // 로직을 수행한다.
    }
}
```
만약 Car 객체의 power 값이 `Power.ON` 인 경우, `turnOff()` 메서드를 호출하다 예외가 발생하면 기존처럼 시동이 걸린 상태로 유지해야 한다는 의미이다.

## 실패 원자적이면 무엇이 좋을까?

예외에 대해 핸들링이 가능하다면, 메서드 호출 전 상태를 유지하기 때문에 객체를 계속 사용할 수 있는 장점이 있다. 단, 주의점들도 있으니 아래 `실패 원자성은 필수일까?` 를 참고해야한다.

## 실패 원자적으로 만드는 방법은 무엇이 있을까?

### 불변객체로 설계하라

가장 간단한 방법은 **불변객체로 설계**하는 것이다. 불변객체는 태생적으로 실패 원자적이다.

```java
// 불변객체
public class Car {
    
    private final Power power;
    
    ...
    
    public Car turnOff() {
        // 로직을 수행한다.
        return new Car(Power.OFF, ...);
    }
}
```
위의 코드처럼 불변객체로 만들게 되면, 로직 수행 중 예외가 발생할 경우 새로운 객체가 만들어지지는 않지만, 시동이 걸린 상태로 계속 유지하기 때문에 가장 간단하게 실패 원자적으로 만들 수 있다.

<br/>

### 작업 수행에 앞서 매개변수의 유효성 검사를 하라

두번째 방법은 **작업 수행에 앞서 매개변수의 유효성 검사를 하는 것**이다.

```java
// 가변 객체
public class Car {
    
    private Power power;
    
    ...
    
    public Car turnOff() {
        if (현재 수행이 가능한 상황이 아니라면) {
            throw new IllegalStateException();
        }
        // power 를 Power.OFF 값으로 변경한다.
        // 로직을 수행한다.
    }
}
```

이렇게 로직 수행전에 유효성 검증을 통해 상태가 변경되지 않도록 유지할 수 있다. 또한, 다른 예를 들면

```java
public Object pop() {
    if (size == 0) {
        throw new EmptyStackException();
    }
    Object result = elements[--size];
    elements[size] = null; // 다 쓴 참조 해제
    return result;
}
```

위의 경우 size 가 0이면 예외를 던지기 때문에, 상태를 유지할 수 있어 실패원자적으로 된다.
> 다만, 위의 예시코드의 경우 size 를 체크하는 로직이 없더라도 size 값이 음수가 되어 예외가 발생하기 때문에 상태가 유지되지만 `OutOfBoundException` 이 발생되어 추상화 수준이 
상황과 어울리지 않다고 불 수 있다. (아이템 73)

<br/>

비슷한 방법으로, **실패할 가능성이 있는 모든 코드를 객체의 상태를 바꾸는 코드보다 앞에 배치**하는 것이다. <br/>
해당 기법은 계산을 수행해보기 전에는 인수의 유효성을 검사해볼 수 없을 때 쓸 수 있는 기법이다.

예를 들면, `TreeMap` 이 있다. TreeMap 은 원소들을 어떤 기준으로 정렬한다. <br/>
TreeMap 에 원소를 추가하려면 그 원소는 TreeMap 기준에 따라 비교할 수 있는 타입이어야 한다. <br/>
엉뚱한 타입의 원소를 추가하려 들면 트리를 변경하기 앞서, 해당 원소가 들어갈 위치를 찾는 과정에서 `ClassCastException` 이 발생하기 때문에 상태가 변하지 않아 실패 원자적이다.

<br/>

### 임시 복사본을 활용하라

세번째 방법은, **객체의 임시 복사본에서 작업을 수행한 다음, 작업이 성공적으로 완료되면 원래 객체와 교체하는 것**이다. <br/>
데이터를 임시 자료구조에 저장해 작업하는게 더 빠를 때 적용하기 좋은 방식이다.

예를 들어, 정렬 메서드에서 정렬을 수행하기 전에 입력 리스트의 원소들을 배열로 옮겨(임시 복사본을 만듬.) 정렬 수행 후, 성공하면 배열에 있는 값을 입력 리스트에 넣어주는 것이다.
이러면, 배열이기 때문에 성능향상 뿐만 아니라 정렬에 실패하더라도 입력 리스트는 변화가 없다.

### 복구 코드를 작성하라

마지막 방법은, **작업 도중 발생하는 실패를 가로채는 복구 코드를 작성하여 작업 전 상태로 되돌리는 방법**이다. <br/>
주로 디스크 기반의 내구성을 보장해야 하는 자료구조에 쓰이는데 자주 쓰이는 방법은 아니다.

## 실패 원자성은 필수일까?

실패 원자성은 일반적으로 권장되는 덕목이지만, 항상 달성할 수 있는 것은 아니다.

두 스레드가 동기화 없이 같은 객체를 동시에 수정한다면 해당 객체의 일관성이 깨질 수 있어, `ConcurrentModificationException` 을 잡아냈다고 해도 그 객체가 여전히 쓸 수 있는 상태라고 가정해서는 안된다. <br/>
또한, Error 는 복수할 수 없으므로 Error 에 대해서는 실패 원자적으로 만를려는 시도조차 할 필요가 없다.

마지막으로 실패 원자성을 당성하기 위한 비용이나 복잡도가 아주 큰 연산도 있기 때문에 필수는 아니다. 그래도, 문제가 무엇인지 알고 나면 실패 원자성을 공짜로 얻을 수 있는 경우가 더 많다.

메서드 명세에 기술한 예외라면 예외가 발생하더라도 객체의 상태는 메서드 호출 전과 똑같이 유지돼야 한다는 것이 기본 규칙이고, 이를 지키지 못한다면 실패 시 객체 상태를 API 설명에 명시해줘야하는데,
대부분이 지켜지고 있지는 않다.

## 이모저모

책에 나오는 내용 중 문제가 무엇인지 알고 나면, 실패 원자성을 공짜로 얻을 수 있는 경우가 더 많다는 언급이 있는데 예시가 있을까?

- 실패원자적으로 가능한지 파헤치다보면 자연스럽게 이해가 되고, 그럼으로써 방어로직을 추가함으로써 공짜로 실패원자성을 얻을 수 있다.
