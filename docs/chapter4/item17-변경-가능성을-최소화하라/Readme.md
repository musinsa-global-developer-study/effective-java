# 변경 가능성을 최소화하라

## 불변클래스는 무엇이고, 어떻게 만들까?

### 불변클래스란?

불변클래스란 간단히 말해 그 **인스턴스의 내부 값을 수정할 수 없는 클래스** 다. 불변 인스턴스에 간직된 정보는 고정되어 객체가 파괴되는 순간까지 절대 달라지지 않는다.

### 저자는 클래스를 불변으로 만들기 위한 규칙 5가지가 있다고 이야기한다.

- 객체의 상태를 변경하는 메서드(변경자)를 제공하지 않는다.
- 클래스를 확장할 수 없도록 한다. 하위 클래스에서 부주의하게 혹은 나쁜 의도로 객체의 상태를 변하게 만드는 사태를 막아준다.
- 모든 필드를 final 로 선언한다. 시스템이 강제하는 수단을 이용해 설계자의 의도를 명확히 드러내는 방버이다.
- 모든 필드를 private 으로 선언한다. 필드가 참조하는 가변 객체를 클라이언트에서 직접 접근해 수정하는 일을 막아준다. <br/> 기술적으로는 불편객체를 참조하는 필드를 public final 로만 선언해도 불변객체가 되자만, 이렇게 하면 다음 릴리스에서 내부 표현을 바꾸지 못하므로 권하지는 않는다.
- 자신 외에는 내부의 가변 컴포넌트에 접근할 수 없도록 한다. 클래스에 가변 객체를 참조하는 필드가 하나라도 있다면 클라이언트에서 그 객체의 참조를 얻을 수 없도록 해야한다. getter 에서도 해당 필드를 참조할 수 있도록 바로 제공하는 것이 아닌 방어적 복사를 수행해야한다.

### 그렇다면, 불변 클래스의 장점은 무엇일까?

#### 1. 불변 객체는 단순하다.

불변객체는 생성된 시점의 상태를 파괴될 때까지 그대로 간직한다. 반면에 가변 객체는 임의의 복잡한 상태에 놓일 수 있어, 변경자 메서드가 일으키는 상태 전이를 정밀하게 문서로 남겨놓지 않은 가변 클래스는 믿고 사용하기 어려울 수 있다.

#### 2. 스레드 안전하다.

불변 객체는 근본적으로 스레드 안전하여 따로 동기화할 필요 없다. 여러 스레드에서 동시에 사용해도 절대 훼손되지 않는다. <br/>
불변 객체에 대해서는 그 어떤 스레드도 다른 스레드에 영향을 줄 수 없으니 불변 객체는 안심하고 공유할 수 있다.

그렇기 때문에 불변객체는 최대한 재활용하기를 권한다.
```java
public static final Complex ZERO = new Complex(0. 0);
public static final Complex ONE = new Complex(1, 0);
```
이처럼 불변 클래스는 자주 사용되는 인스턴스를 상수로 제공할 수 도 있고, 캐싱하여 같은 인스턴스를 중복 생성하지 않게 해주는 정적 팩토리 메서드를 제공할 수 있다.

또한, 불변 객체는 자유롭게 공유할 수 있다는 점은 방어적 복사도 필요 없다는 결론으로 이어진다.

#### 3. 불변 객체 끼리는 내부 데이터를 공유할 수 있다.

불변 객체는 자유롭게 공유할 수 있음은 물론, 불변 객체끼리는 내부 데이터를 공유할 수 있다. <br/>
예컨대 BigInteger 클래스는 내부에서 값의 부호(sign)와 크기(magnitude)를 따로 표현한다. 부호는 int 변수를, 크기(절댓값)에 int 배열을 사용하는 것이다. <br/>
한편 negate 메서드는 크기가 같고 부호만 반대인 새로운 BigInteger를 생성하는데, 이때 배열은 비록 가변이지만 방어적 복사하지 않고 원본 인스턴스와 공유해도 된다. <br/>
그 결과 새로 만든 BigInteger 인스턴스도 원본 인스턴스가 가리키는 내부 배열을 그대로 가리킨다.

#### 4. 객체를 생성할 때 불편 객체들을 구성요소로 사용하면 이점이 많다.

객체를 만들 때 다른 불변 객체들을 구성요소로 사용하면 이점이 많은데, 값이 바뀌지 않는 구성요소들로 이뤄진 객체라면, 그 구조가 아무리 복잡하더라도 불변식을 유지하기 훨씬 수월하기 때문이다.

#### 5. 실패원자성을 제공한다.

불변 객체는 그 자체로 실패원자성을 제공한다. 상태가 절대 변하지 않으니 잠깐이라도 불일치 상태에 빠질 가능성이 없다.

### 불변 클래스는 단점이 없을까?

불변 클래스에도 단점은 있다. 값이 다르면 반드시 독립된 객체로 만들어야 한다는 것이다. 값의 가짓수가 많다면 이들을 모두 만드는 데 큰 비용을 치러야 한다. <br/>
예를 들어 백만 비트짜리 BigInteger 에서 비트 하나를 바꿔야 한다고 해보자.

```java
BigInteger moby = ...;
moby = moby.flipBit(0);
```
filpBit 메서드는 새로운 BigInteger 인스턴스를 생성한다. 원본과 단지 한 비트만 다른 백만 비트짜리 인스턴스를 말이다.
이처럼, 원하는 객체를 완성하기까지의 단계가 많고, 그 중간 단계에서 만들어진 객체들이 모두 버려진다면 성능 문제가 더 불거진다. 이 문제를 대처하는 방법은 두 가지 이다.

#### 첫번째는 private-package 가변 동반클래스를 활용하라

흔히 쓰일 다단계 연산들을 예측하여 기본 기능으로 제공하는 것이다. 이러한 다단계 연산을 기본으로 제공한다면 더 이상 각 단계마다 객체를 생성하지 않아도 된다. 예를 들어, BigInteger 는 모듈러 지수 같은 다단계 연산 속도를 높여주는 **가변 동반 클래스를
private-package 으로 두고 있다.** 

#### 두번째는 
