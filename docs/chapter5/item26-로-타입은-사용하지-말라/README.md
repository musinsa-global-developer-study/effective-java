# 로 타입은 사용하지 말라
## 용어 정리
- 클래스와 인터페이스에 타입 매개변수가 쓰이면 `제네릭 클래스` 혹은 `제네릭 인터페이스`라고 한다.
- 제네릭 클래스와 제네릭 인터페이스를 통틀어서 `제네릭 타입`이라 한다.
- `타입 매개 변수`는 `E`와 같이 주로 대문자 알파벳을 사용해서 표기한다.
- List<String>과 같이 표기된 형태를 `매개 변수화 타입`이라 한다.(원소의 타입이 String인 리스트를 뜻하는 매개변수화 타입)
  - `(정규) 타입 매개 변수`는 `E`이다.
  - `실제 타입 매개 변수`는 `String`이다.
- `로 타입`은 제네릭 타입에서 타입 매개 변수를 전혀 사용하지 않을 때를 말한다.

## 로 타입이 등장하게 된 이유
제네릭이 도래하기 전 코드와 호환되도록 하기 위한 궁여지책이다.(자바 5이전 버전에서는 제네릭 개념이 없었다)


## 로 타입의 문제점
제네릭이 지원하기 전에는 다음과 같이 코드를 작성했다. 개발자가 실수로 stamp 타입 대신에 coin 타입을 넣어도 컴파일 시점에 체크가 되지 않았다.
```java
// Stamp 인스턴스만 취급한다.
private final Collection stamps = ...;

// 실수로 동전을 넣는다.
stamps.add(new Coin(...));

for (Iterator i = stamps.iterator(); i.hasNext();) {
    Stamp stamp = (Stamp) i.ndex(); // ClassCastException 발생
    stamp.cancel();
}
```
런타임에 문제를 겪는 코드와 원인을 제공한 코드가 물리적으로 상당히 떨어져 있을 가능성이 커진다. 
ClassCastException이 발생하면 stamp에 동전을 넣은 지점을 찾기 위해 코드 전체를 훑어봐야 할 수도 있다.

제네릭을 사용해서 컴파일 시점에 해당 컬렉션이 어떤 타입을 받을지 알 수 있도록 하자. 
컴파일러는 컬렉션에서 원소를 꺼내는 모든 곳에 보이지 않는 형변환을 추가하여 절대 실패하지 않음을 보장한다.
```java
private final Collection<Stamp> stamps = ...;
```

**로 타입을 쓰면 제네릭이 안겨주는 안전성과 표현력을 모두 잃게 된다.**

## 실제 타입 매개 변수를 신경쓰고 싶지않은 경우는 비한정적 와일드카드 타입을 사용하자.

2개의 집합(Set)을 받아 공통 원소를 반환하는 메서드를 작성한다고 해보자. 제네릭 없이 작성된 코드이다.
동작은 하지만 로 타입을 사용해서 안전하지 않다.
```java
static int numElementsInCommon(Set s1, Set s2) {
    int result = 0;
    for (Object o1 : s1) {
        if (s2.contains(o1)) {
            result ++;
        }
    }
    return result;
}
```

이 경우는 비한정적 와일드카드 타입을 대신 사용하는게 좋다. 
제네릭 타입을 쓰고 싶지만 실제 타입 매개변수가 무엇인지 신경 쓰고 싶지 않다면 물음표(?)를 사용하자.
```java
static int numElementsInCommonWithGeneric(Set<?> s1, Set<?> s2) {
    int result = 0;
    for (Object o1 : s1) {
        if (s2.contains(o1)) {
            result ++;
        }
    }
    return result;
}
```
둘의 차이는 뭘까? 와일드카드 타입은 안전하고, 로 타입은 안전하지 않다는 것이다.

로 타입은 아무 원소나 넣을 수 있으므로 타입 불변식을 훼손하기 쉽지만, `Collection<?>에는 (null 외에는) 어떤 원소도 넣을 수 없다.`
다른 원소를 넣으려고 한다면 컴파일 단계에서 오류가 발생한다. (이러한 제약을 받아들일 수 없다면 제네릭 메서드나 한정적 와일드 카드 타입을 사용하면 된다. - 아이템 30, 31)

## 로 타입을 써야하는 예외 케이스
클래스 리터럴에는 로 타입을 써야한다.
- 자바 명세는 class 리터럴에 매개변수화 타입을 사용하지 못하게 했다.
- List.class, String[].class, int.class는 허용하지만 List<String>.class와 List<?>.class는 허용하지 않는다.

instanceof 연산자는 비한정적 와일드카드 타입 이외의 매개변수화 타입에는 적용할 수 없다.
- 로 타입이든 비한정적 와일드카드 타입이든 instanceof는 완전히 똑같이 동작한다.
- 따라서 <?>는 아무런 역할을 하지 못하므로 차라리 로 타입을 쓰는편이 코드가 깔끔하다
```java

if (o instanceof Set) { // 로 타입
    Set<?> s = (Set<?>) o; // 와일드카드 타입
    ...
}
```
o의 타입이 Set임을 확인한 다음 와일드카드 타입인 Set<?>로 형변환한다. 이는 검사 형변환(checked cast)이므로 컴파일러 경고가 뜨지 않는다.