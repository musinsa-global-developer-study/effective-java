# 자바 직렬화의 대안을 찾으라

## 객체 직렬화란?
자바가 객체를 바이트 스트림으로 인코딩하고(직렬화) 그 바이트 스트림으로부터 다시 객체를 재구성하는(역직렬화) 메커니즘이다.

## 바이트 스트림이란?
바이트는 8개의 bit가 모여 구성된다.

8개의 bit를 독립된 데이터로 인식하고 이 데이터를 순차적으로 전달하는것이 바이트 스트림이다. (비트에 의미를 부여하는게 아닌 바이트에 의미를 부여함)

바이트 스트림은 주로 문자, 사진, 영상 등을 전달할 때 사용된다. 바이트 스트림에 들어있는 데이터를 어떻게 해석할지는 송신,수신자 간에 약속이 되어있어야 한다. 

## 첫 등장
1997년 자바에 처음으로 직렬화가 도입되었다. 그 당시 직렬화는 연구용 언어인 모듈라-3에서나 시도되었고, 대중적인 언어에는 적용된 적이 없었기 때문에 다소 위험한것 아니냐는 이야기가 나왔다.

보이지 않는 생성자, API와 구현 사이의 모호해진 경계, 잠재적인 정확성 문제, 성능, 보안, 유지보수성 등 각종 문제를 불러 일으켰다.

그 중 보안 문제는 심각했다.

## 직렬화의 문제점
직렬화의 근본적인 문제는 공격 범위가 너무 넓고 지속적으로 더 넓어져 방어하기 어렵다는 점이다.

`ObjectInputStream`의 `readObject` 메소드를 호출하면서 객체 그래프가 역직렬화 되기 떄문이다. 
`readObjct` 메서드는 클래스패스 안의 거의 모든 타입의 객체를 만들어 낼 수 있는 생성자다.

바이트 스트림을 역직렬화하는 과정에서 이 메서드는 그 타입들 안의 모든 코드를 수행할 수 있다.(즉, 그 타입들의 코드 전체가 공격 범위에 들어간다는 뜻이다.)

## 가젯

연구자들은 서드파티 라이브러리에서 직렬화 가능 타입들을 연구하여 역직렬화 과정에서 호출되어 잠재적으로 위험한 동작을 수행하는 메서드들을 찾아보았다.
이런 메서드를 가젯(gadget)이라 부른다.

가끔씩 공격자가 기반 하드웨어의 네이티브 코드를 마음대로 실행할 수 있는 가젯 체인(여러 가젯을 엮은 것)이 발견되기도 한다.
샌프란시스코 교통국을 마비시킨 공격이 정확히 이런 사례다.(2016년 11월에 발생했으며 이틀간 요금 징수 시스템이 마비되었다)

그래서 아주 신중하게 제작한 바이트 스트림만 역직렬화해야 한다.

## 역직렬화 폭탄
사실 가젯까지도 갈 필요 없이, 역직렬화에 시간이 오래 걸리는 짧은 스트림을 역직렬화하는 것만으로도 서비스 거부 공격에 쉽게 노출될 수 있다.

이런 스트림을 역직렬화 폭탄이라고 한다.

이 객체 그래프는 201개의 HashSet 인스턴스로 구성된다.

스트림 전체 크기는 5,744 바이트이지만 역직렬화는 태양이 불타 식을 때까지도 끝나지 않을 것이다.
HashSet을 역직렬화하려면 hashCode 메서드를 2^100번 넘게 호출해야한다. 

역직렬화가 영원히 계속된다는 것도 문제지만, 무언가 잘못되었다는 신호조차 주지 않는다는 것도 큰 문제다.

```java
static byte[] bomb() {
    Set<Object> root = new HashSet<>();
    Set<Object> s1 = root;
    Set<Object> s2 = new HashSet<>(); // 인스턴스 1개 생성
    for (int i = 0; i < 100; i++) {
        Set<Object> t1 = new HashSet<>(); // 인스턴스가 100개 생성될 것이다.
        Set<Object> t2 = new HashSet<>(); // 인스턴스가 100개 생성될 것이다.
        t1.add("foo"); // t1에 "foo" 추가
        s1.add(t1); // s1(root)에 t1 추가
        s1.add(t2); // s1(root)에 t2 추가
        s2.add(t1); // s2에 t1추가
        s2.add(t2); // s2에 t2추가
        s1 = t1; // t1의 참조값을 s1(root)에 할당
        s2 = t2; // t2의 참조값을 s2에 할당
    }
    
    return serialize(root); // 직렬화 메소드는 생략
}
```

## 해결법
직렬화 위험을 회피하는 가장 좋은 방법은 아무것도 역직렬화하지 않는 것이다.

여러분이 작성하는 새로운 시스템에서 자바 직렬화를 써야 할 이유는 전혀 없다.

객체와 바이트 시퀀스를 변환해주는 다른 매커니즘이 많이 있다. (이 책에서는 크로스-플랫폼 구조화된 데이터 표현이라 부름)

## 크로스-플랫폼 구조화된 데이터 표현
대표적으로 JSON과 프로토콜 버퍼(protobuf)가 있다.

JSON은 더글라스 크록퍼드가 브라우저와 서버의 통신용으로 설계했고, 프로토콜 버퍼는 구글이 서버 사이에 데이터를 교환하고 저장하기 위해 설계했다.

둘의 가장 큰 차이는 JSON은 텍스트 기반이라 사람이 읽을 수 있고, 프로토콜 버퍼는 이진 표현이라 효율이 훨씬 높다.

## ObjectInputFilter
직렬화를 피할 수 없고 역직렬화한 데이터가 안전한지 완전히 확신할 수 없다면 객체 역직렬화 필터링(java.io.ObjectInputFilter)을 사용하자.

자바 9에 추가되었고, 이전 버전에서도 쓸 수 있도록 이식 되었다.

`ObjectInputFilter`는 데이터 스트림이 역직렬화 되기 전에 필터를 설치하는 기능이다.

기본수용 모드와 기본 거부 모드가 있다. 기본 거부 모드는 화이트리스트에 기록된 안전하다고 알려진 클래스만 수용한다.
가능하면 화이트 리스트를 사용하는 기본 거부 모드를 사용하자.

그러나 결국 `ObjectInputFilter`도 앞서 보여준 역직렬화 폭탄은 걸러내지 못한다.

안타깝게도 직렬화는 자바 생태계 곳곳에서 쓰이고 있는데 가능하면 시간과 노력을 들여서 크로스-플랫폼 구조화된 데이터 표현으로 마이그레이션 하길 바란다.