# 프로그램의 동작을 스레드 스케줄러에 기대지 마라

## 운영체제의 스레드 스케줄링

여러 쓰레드가 실행 가능 상태(runnable) 상태일때, 스레드 스케쥴러는 어떤 스레드를 얼마나 오래 실행할지 결정한다.

스케줄링 정책은 운영체제 마다 다를 수 있다. 따라서 `잘 작성된 프로그램이라면 이 정책에 좌지우지돼서는 안된다.`

> 정확성이나 성능이 스레드 스케줄러에 따라 달라지는 프로그램이라면 다른 플랫폼에 이식하기 어렵다.

## 적절한 스레드 개수

견고하고, 이식성 좋은 프로그램을 작성하기 위해선 실행 가능(runnable)한 스레드의 평균적인 수를 프로세서 수보다 너무 많아지지 않도록 하는것이다.

이렇게 하면 실행 가능(runnable)한 스레드가 남지 않을 때까지 작업을 할당할 수 있다.

> 실행 가능(runnable) 스레드가 줄어든다는 것은 스레드 스케쥴러의 고민이 줄어드는 것을 의미하기 때문이다!!

## 실행 가능한 스레드와 전체 스레드

`실행 가능(runnable)한 스레드의 수`와 `전체 스레드 수`는 다른 것임을 알아야한다. 

Why? 대기 중인 스레드가 존재하기 떄문이다. 대기 중인 쓰레드는 실행가능한 상태가 아니라 일을 처리할 수 없다. (다른 스레드가 작업을 점유하고 있는 동안 while문을 순회한다고 생각)

대기중인 스레드는 다른 스레드가 일이 끝나기를 기다리는 상태이다.

실행 가능 상태 스레드가 적도록 유지하는 방법은 각 스레드가 유용한 작업을 완료한 후에 다음 일거리가 생일 때까지 대기하는 것이다. (실행 후 wating 상태로 전환)

또한, 작업은 짧게 유지하면 좋다. 다만 너무 짧으면 작업을 분배하는데 있어서 부하가 걸려 성능이 낮아질 수 있다.

## 바쁜 대기 (Busy Waiting)

다만 주의해야할 점은 스레드가 절대 `바쁜 대기 상태`가 되면 안된다.

바쁜 대기는 스레드 스케줄러의 변덕에 취약할 뿐 아니라, 프로세서에 큰 부담을 주어 다른 유용한 작업이 실행될 기회를 박탈한다.

### 바쁜 대기란?
- 쓰레드가 반복적으로 if조건을 검사하면서 다음 작업을 대기한다.
- 정확한 대기시간을 알려주지 못하는 시스템에선 쓰이곤 한다.
- 대부분의 경우에는 안티패턴이다. 리소스 낭비가 큰 문제!


아래 예시를 보자.

```java
public class SlowCountDownLatch {
    private int count;

    public SlowCountDownLatch(int count) {
        if (count < 0) {
            throw new IllegalArgumentException(count + " < 0");
        }
        this.count = count;
    }

    public void await() {
        while(true) { // 쓰레드가 바쁜 대기 상태가 될 가능성
            synchronized (this) {
                if(count == 0) {
                    return;
                }
            }
        }
    }

    public synchronized void countDown() {
        if (count != 0) {
            count--;
        }
    }

}
```
하나 이상의 쓰레드가 불필요하게 실행 가능한 상태로 존재하는 시스템도 심심찮게 볼 수 있다. (적절한 스레드 개수를 산정하지 못한것임.)


`Thread.yield`를 써서 문제를 해결하고 싶겠지만, 증상은 어느 정도 호전되나 이식성이 낮아진다. `Thread.yield`는 테스트할 수단도 없다.

차라리 애플리케이션 구조를 바꿔 동시에 실행 가능한 스레드 수가 적어지도록 조치해주자. (괜히 쓰레드 낭비하지 말자.)




